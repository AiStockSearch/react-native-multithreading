diff --git a/node_modules/react-native-reanimated/Common/cpp/NativeModules/NativeReanimatedModule.cpp b/node_modules/react-native-reanimated/Common/cpp/NativeModules/NativeReanimatedModule.cpp
index e5a6aa8..878f15a 100644
--- a/node_modules/react-native-reanimated/Common/cpp/NativeModules/NativeReanimatedModule.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/NativeModules/NativeReanimatedModule.cpp
@@ -61,37 +61,25 @@ NativeReanimatedModule::NativeReanimatedModule(std::shared_ptr<CallInvoker> jsIn
                                                std::unique_ptr<jsi::Runtime> rt,
                                                std::shared_ptr<ErrorHandler> errorHandler,
                                                std::function<jsi::Value(jsi::Runtime &, const int, const jsi::String &)> propObtainer,
-                                               PlatformDepMethodsHolder platformDepMethodsHolder) : NativeReanimatedModuleSpec(jsInvoker),
-                                                  runtime(std::move(rt)),
+                                               PlatformDepMethodsHolder platformDepMethodsHolder) :
+                                                  NativeReanimatedModuleSpec(jsInvoker),
+                                                  RuntimeManager(std::move(rt), errorHandler, scheduler),
                                                   mapperRegistry(new MapperRegistry()),
                                                   eventHandlerRegistry(new EventHandlerRegistry()),
                                                   requestRender(platformDepMethodsHolder.requestRender),
-                                                  propObtainer(propObtainer),
-                                                  errorHandler(errorHandler),
-                                                  workletsCache(new WorkletsCache()),
-                                                  scheduler(scheduler)
+                                                  propObtainer(propObtainer)
 {
   auto requestAnimationFrame = [=](FrameCallback callback) {
     frameCallbacks.push_back(callback);
     maybeRequestRender();
   };
 
-  RuntimeDecorator::addNativeObjects(*runtime,
-                                     platformDepMethodsHolder.updaterFunction,
-                                     requestAnimationFrame,
-                                     platformDepMethodsHolder.scrollToFunction,
-                                     platformDepMethodsHolder.measuringFunction,
-                                     platformDepMethodsHolder.getCurrentTime);
-}
-
-bool NativeReanimatedModule::isUIRuntime(jsi::Runtime &rt)
-{
-  return runtime.get() == &rt;
-}
-
-bool NativeReanimatedModule::isHostRuntime(jsi::Runtime &rt)
-{
-  return !isUIRuntime(rt);
+  RuntimeDecorator::decorateUIRuntime(*runtime,
+                                      platformDepMethodsHolder.updaterFunction,
+                                      requestAnimationFrame,
+                                      platformDepMethodsHolder.scrollToFunction,
+                                      platformDepMethodsHolder.measuringFunction,
+                                      platformDepMethodsHolder.getCurrentTime);
 }
 
 void NativeReanimatedModule::installCoreFunctions(jsi::Runtime &rt, const jsi::Value &valueSetter)
diff --git a/node_modules/react-native-reanimated/Common/cpp/SharedItems/FrozenObject.cpp b/node_modules/react-native-reanimated/Common/cpp/SharedItems/FrozenObject.cpp
index 9cafe7f..f00e313 100644
--- a/node_modules/react-native-reanimated/Common/cpp/SharedItems/FrozenObject.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/SharedItems/FrozenObject.cpp
@@ -1,15 +1,16 @@
 #include "FrozenObject.h"
 #include "SharedParent.h"
 #include "ShareableValue.h"
+#include "RuntimeManager.h"
 
 namespace reanimated {
 
-FrozenObject::FrozenObject(jsi::Runtime &rt, const jsi::Object &object, NativeReanimatedModule *module) {
+FrozenObject::FrozenObject(jsi::Runtime &rt, const jsi::Object &object, RuntimeManager *runtimeManager) {
   auto propertyNames = object.getPropertyNames(rt);
   for (size_t i = 0, count = propertyNames.size(rt); i < count; i++) {
     auto propertyName = propertyNames.getValueAtIndex(rt, i).asString(rt);
     std::string nameStr = propertyName.utf8(rt);
-    map[nameStr] = ShareableValue::adapt(rt, object.getProperty(rt, propertyName), module);
+    map[nameStr] = ShareableValue::adapt(rt, object.getProperty(rt, propertyName), runtimeManager);
     this->containsHostFunction |= map[nameStr]->containsHostFunction;
   }
 }
diff --git a/node_modules/react-native-reanimated/Common/cpp/SharedItems/MutableValue.cpp b/node_modules/react-native-reanimated/Common/cpp/SharedItems/MutableValue.cpp
index 54ad9bc..e88426d 100644
--- a/node_modules/react-native-reanimated/Common/cpp/SharedItems/MutableValue.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/SharedItems/MutableValue.cpp
@@ -1,13 +1,14 @@
 #include "MutableValue.h"
 #include "SharedParent.h"
 #include "ShareableValue.h"
-#include "NativeReanimatedModule.h"
+#include "RuntimeManager.h"
+#include "RuntimeDecorator.h"
 
 namespace reanimated {
 
 void MutableValue::setValue(jsi::Runtime &rt, const jsi::Value &newValue) {
   std::lock_guard<std::mutex> lock(readWriteMutex);
-  value = ShareableValue::adapt(rt, newValue, module);
+  value = ShareableValue::adapt(rt, newValue, runtimeManager);
 
   std::shared_ptr<MutableValue> thiz = shared_from_this();
   auto notifyListeners = [thiz] () {
@@ -16,10 +17,10 @@ void MutableValue::setValue(jsi::Runtime &rt, const jsi::Value &newValue) {
     }
   };
 
-  if (module->isUIRuntime(rt)) {
+  if (RuntimeDecorator::isWorkletRuntime(rt)) {
     notifyListeners();
   } else {
-    module->scheduler->scheduleOnUI([notifyListeners] {
+    runtimeManager->scheduler->scheduleOnUI([notifyListeners] {
       notifyListeners();
     });
   }
@@ -33,14 +34,14 @@ jsi::Value MutableValue::getValue(jsi::Runtime &rt) {
 void MutableValue::set(jsi::Runtime &rt, const jsi::PropNameID &name, const jsi::Value &newValue) {
   auto propName = name.utf8(rt);
 
-  if (module->isHostRuntime(rt)) {
+  if (RuntimeDecorator::isReactRuntime(rt)) {
     if (propName == "value") {
-      auto shareable = ShareableValue::adapt(rt, newValue, module);
-      module->scheduler->scheduleOnUI([this, shareable] {
-        jsi::Runtime &rt = *this->module->runtime.get();
+      auto shareable = ShareableValue::adapt(rt, newValue, runtimeManager);
+      runtimeManager->scheduler->scheduleOnUI([this, shareable] {
+        jsi::Runtime &rt = *this->runtimeManager->runtime.get();
         auto setterProxy = jsi::Object::createFromHostObject(rt, std::make_shared<MutableValueSetterProxy>(shared_from_this()));
         jsi::Value newValue = shareable->getValue(rt);
-        module->valueSetter->getValue(rt)
+        runtimeManager->valueSetter->getValue(rt)
           .asObject(rt)
           .asFunction(rt)
           .callWithThis(rt, setterProxy, newValue);
@@ -52,7 +53,7 @@ void MutableValue::set(jsi::Runtime &rt, const jsi::PropNameID &name, const jsi:
   // UI thread
   if (propName == "value") {
     auto setterProxy = jsi::Object::createFromHostObject(rt, std::make_shared<MutableValueSetterProxy>(shared_from_this()));
-    module->valueSetter->getValue(rt)
+    runtimeManager->valueSetter->getValue(rt)
       .asObject(rt)
       .asFunction(rt)
       .callWithThis(rt, setterProxy, newValue);
@@ -72,7 +73,7 @@ jsi::Value MutableValue::get(jsi::Runtime &rt, const jsi::PropNameID &name) {
     return getValue(rt);
   }
 
-  if (module->isUIRuntime(rt)) {
+  if (RuntimeDecorator::isWorkletRuntime(rt)) {
     // _value and _animation should be accessed from UI only
     if (propName == "_value") {
       return getValue(rt);
@@ -94,8 +95,8 @@ std::vector<jsi::PropNameID> MutableValue::getPropertyNames(jsi::Runtime &rt) {
   return result;
 }
 
-MutableValue::MutableValue(jsi::Runtime &rt, const jsi::Value &initial, NativeReanimatedModule *module, std::shared_ptr<Scheduler> s):
-StoreUser(s), module(module), value(ShareableValue::adapt(rt, initial, module)) {
+MutableValue::MutableValue(jsi::Runtime &rt, const jsi::Value &initial, RuntimeManager *runtimeManager, std::shared_ptr<Scheduler> s):
+StoreUser(s), runtimeManager(runtimeManager), value(ShareableValue::adapt(rt, initial, runtimeManager)) {
 }
 
 unsigned long int MutableValue::addListener(unsigned long id, std::function<void ()> listener) {
diff --git a/node_modules/react-native-reanimated/Common/cpp/SharedItems/RemoteObject.cpp b/node_modules/react-native-reanimated/Common/cpp/SharedItems/RemoteObject.cpp
index c3efbcc..a55e47d 100644
--- a/node_modules/react-native-reanimated/Common/cpp/SharedItems/RemoteObject.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/SharedItems/RemoteObject.cpp
@@ -1,6 +1,6 @@
 #include "RemoteObject.h"
 #include "SharedParent.h"
-#include "NativeReanimatedModule.h"
+#include "RuntimeDecorator.h"
 #include <jsi/jsi.h>
 
 using namespace facebook;
@@ -16,14 +16,14 @@ void RemoteObject::maybeInitializeOnUIRuntime(jsi::Runtime &rt) {
 }
 
 jsi::Value RemoteObject::get(jsi::Runtime &rt, const jsi::PropNameID &name) {
-  if (module->isUIRuntime(rt)) {
+  if (RuntimeDecorator::isWorkletRuntime(rt)) {
     return backing.lock()->getObject(rt).getProperty(rt, name);
   }
   return jsi::Value::undefined();
 }
 
 void RemoteObject::set(jsi::Runtime &rt, const jsi::PropNameID &name, const jsi::Value &value) {
-  if (module->isUIRuntime(rt)) {
+  if (RuntimeDecorator::isWorkletRuntime(rt)) {
     backing.lock()->getObject(rt).setProperty(rt, name, value);
   }
   // TODO: we should throw if trying to update remote from host runtime
diff --git a/node_modules/react-native-reanimated/Common/cpp/SharedItems/ShareableValue.cpp b/node_modules/react-native-reanimated/Common/cpp/SharedItems/ShareableValue.cpp
index ab8b639..242fb5a 100644
--- a/node_modules/react-native-reanimated/Common/cpp/SharedItems/ShareableValue.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/SharedItems/ShareableValue.cpp
@@ -1,10 +1,11 @@
 #include "ShareableValue.h"
 #include "SharedParent.h"
-#include "NativeReanimatedModule.h"
+#include "RuntimeManager.h"
 #include "MutableValue.h"
 #include "MutableValueSetterProxy.h"
 #include "RemoteObject.h"
 #include "FrozenObject.h"
+#include "RuntimeDecorator.h"
 
 namespace reanimated {
 
@@ -38,7 +39,7 @@ void freeze(jsi::Runtime &rt, jsi::Object &obj) {
 void ShareableValue::adaptCache(jsi::Runtime &rt, const jsi::Value &value) {
   // when adapting from host object we can assign cached value immediately such that we avoid
   // running `toJSValue` in the future when given object is accessed
-  if (module->isUIRuntime(rt)) {
+  if (RuntimeDecorator::isWorkletRuntime(rt)) {
     if (remoteValue.expired()) {
       remoteValue = getWeakRef(rt);
     }
@@ -49,7 +50,7 @@ void ShareableValue::adaptCache(jsi::Runtime &rt, const jsi::Value &value) {
 }
 
 void ShareableValue::adapt(jsi::Runtime &rt, const jsi::Value &value, ValueType objectType) {
-  bool isRNRuntime = !(module->isUIRuntime(rt));
+  bool isRNRuntime = RuntimeDecorator::isReactRuntime(rt);
   if (value.isObject()) {
     jsi::Object object = value.asObject(rt);
     jsi::Value hiddenValue = object.getProperty(rt, HIDDEN_HOST_OBJECT_PROP);
@@ -74,7 +75,7 @@ void ShareableValue::adapt(jsi::Runtime &rt, const jsi::Value &value, ValueType
   if (objectType == ValueType::MutableValueType) {
     type = ValueType::MutableValueType;
     valueContainer = std::make_unique<MutableValueWrapper>(
-      std::make_shared<MutableValue>(rt, value, module, module->scheduler)
+      std::make_shared<MutableValue>(rt, value, runtimeManager, runtimeManager->scheduler)
     );
   } else if (value.isUndefined()) {
     type = ValueType::UndefinedType;
@@ -103,7 +104,7 @@ void ShareableValue::adapt(jsi::Runtime &rt, const jsi::Value &value, ValueType
       } else {
         // a worklet
         type = ValueType::WorkletFunctionType;
-        valueContainer = std::make_unique<FrozenObjectWrapper>(std::make_shared<FrozenObject>(rt, object, module));
+        valueContainer = std::make_unique<FrozenObjectWrapper>(std::make_shared<FrozenObject>(rt, object, runtimeManager));
         auto& frozenObject = ValueWrapper::asFrozenObject(valueContainer);
         containsHostFunction |= frozenObject->containsHostFunction;
         if (isRNRuntime && !containsHostFunction) {
@@ -116,7 +117,7 @@ void ShareableValue::adapt(jsi::Runtime &rt, const jsi::Value &value, ValueType
       valueContainer = std::make_unique<FrozenArrayWrapper>();
       auto& frozenArray = ValueWrapper::asFrozenArray(valueContainer);
       for (size_t i = 0, size = array.size(rt); i < size; i++) {
-        auto sv = adapt(rt, array.getValueAtIndex(rt, i), module);
+        auto sv = adapt(rt, array.getValueAtIndex(rt, i), runtimeManager);
         containsHostFunction |= sv->containsHostFunction;
         frozenArray.push_back(sv);
       }
@@ -133,13 +134,13 @@ void ShareableValue::adapt(jsi::Runtime &rt, const jsi::Value &value, ValueType
     } else if (objectType == ValueType::RemoteObjectType) {
       type = ValueType::RemoteObjectType;
       valueContainer = std::make_unique<RemoteObjectWrapper>(
-        std::make_shared<RemoteObject>(rt, object, module, module->scheduler)
+        std::make_shared<RemoteObject>(rt, object, runtimeManager, runtimeManager->scheduler)
       );
     } else {
       // create frozen object based on a copy of a given object
       type = ValueType::FrozenObjectType;
       valueContainer = std::make_unique<FrozenObjectWrapper>(
-        std::make_shared<FrozenObject>(rt, object, module)
+        std::make_shared<FrozenObject>(rt, object, runtimeManager)
       );
       auto& frozenObject = ValueWrapper::asFrozenObject(valueContainer);
       containsHostFunction |= frozenObject->containsHostFunction;
@@ -158,15 +159,15 @@ void ShareableValue::adapt(jsi::Runtime &rt, const jsi::Value &value, ValueType
   }
 }
 
-std::shared_ptr<ShareableValue> ShareableValue::adapt(jsi::Runtime &rt, const jsi::Value &value, NativeReanimatedModule *module, ValueType valueType) {
-  auto sv = std::shared_ptr<ShareableValue>(new ShareableValue(module, module->scheduler));
+std::shared_ptr<ShareableValue> ShareableValue::adapt(jsi::Runtime &rt, const jsi::Value &value, RuntimeManager *runtimeManager, ValueType valueType) {
+  auto sv = std::shared_ptr<ShareableValue>(new ShareableValue(runtimeManager, runtimeManager->scheduler));
   sv->adapt(rt, value, valueType);
   return sv;
 }
 
 jsi::Value ShareableValue::getValue(jsi::Runtime &rt) {
   // TODO: maybe we can cache toJSValue results on a per-runtime basis, need to avoid ref loops
-  if (module->isUIRuntime(rt)) {
+  if (RuntimeDecorator::isWorkletRuntime(rt)) {
     if (remoteValue.expired()) {
       auto ref = getWeakRef(rt);
       remoteValue = ref;
@@ -212,7 +213,7 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
       return jsi::Value(ValueWrapper::asNumber(valueContainer));
     case ValueType::StringType: {
       auto& stringValue = ValueWrapper::asString(valueContainer);
-      return jsi::Value(rt, jsi::String::createFromAscii(rt, stringValue));
+      return jsi::Value(rt, jsi::String::createFromUtf8(rt, stringValue));
     }
     case ValueType::FrozenObjectType: {
       auto& frozenObject = ValueWrapper::asFrozenObject(valueContainer);
@@ -228,7 +229,7 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
     }
     case ValueType::RemoteObjectType: {
       auto& remoteObject = ValueWrapper::asRemoteObject(valueContainer);
-      if (module->isUIRuntime(rt)) {
+      if (RuntimeDecorator::isWorkletRuntime(rt)) {
         remoteObject->maybeInitializeOnUIRuntime(rt);
       }
       return createHost(rt, remoteObject);
@@ -246,10 +247,10 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
         // function is accessed from a different runtime, we wrap function in host func that'd enqueue
         // call on an appropriate thread
 
-        auto module = this->module;
+        auto runtimeManager = this->runtimeManager;
         auto hostFunction = hostFunctionWrapper->value;
 
-        auto warnFunction = [module, hostFunction](
+        auto warnFunction = [runtimeManager, hostFunction](
             jsi::Runtime &rt,
             const jsi::Value &thisValue,
             const jsi::Value *args,
@@ -267,14 +268,14 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
           exceptionMessage += " from a different thread.\n\nOccurred in worklet location: ";
           exceptionMessage += workletLocation;
           exceptionMessage += CALLBACK_ERROR_SUFFIX;
-          module->errorHandler->setError(exceptionMessage);
-          module->errorHandler->raise();
+          runtimeManager->errorHandler->setError(exceptionMessage);
+          runtimeManager->errorHandler->raise();
 
           return jsi::Value::undefined();
         };
 
         auto hostRuntime = hostFunctionWrapper->hostRuntime;
-        auto clb = [module, hostFunction, hostRuntime](
+        auto clb = [runtimeManager, hostFunction, hostRuntime](
             jsi::Runtime &rt,
             const jsi::Value &thisValue,
             const jsi::Value *args,
@@ -285,7 +286,7 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
 
           std::vector<std::shared_ptr<ShareableValue>> params;
           for (int i = 0; i < count; ++i) {
-            params.push_back(ShareableValue::adapt(rt, args[i], module));
+            params.push_back(ShareableValue::adapt(rt, args[i], runtimeManager));
           }
 
           std::function<void()> job = [hostFunction, hostRuntime, params] {
@@ -302,7 +303,7 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
             // ToDo use returned value to return promise
           };
 
-          module->scheduler->scheduleOnJS(job);
+          runtimeManager->scheduler->scheduleOnJS(job);
           return jsi::Value::undefined();
         };
         jsi::Function wrapperFunction = jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "hostFunction"), 0, warnFunction);
@@ -312,13 +313,13 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
       }
     }
     case ValueType::WorkletFunctionType: {
-      auto module = this->module;
+      auto runtimeManager = this->runtimeManager;
       auto& frozenObject = ValueWrapper::asFrozenObject(this->valueContainer);
-      if (module->isUIRuntime(rt)) {
+      if (RuntimeDecorator::isWorkletRuntime(rt)) {
         // when running on UI thread we prep a function
 
-        auto jsThis = std::make_shared<jsi::Object>(frozenObject->shallowClone(*module->runtime));
-        std::shared_ptr<jsi::Function> funPtr(module->workletsCache->getFunction(rt, frozenObject));
+        auto jsThis = std::make_shared<jsi::Object>(frozenObject->shallowClone(*runtimeManager->runtime));
+        std::shared_ptr<jsi::Function> funPtr(runtimeManager->workletsCache->getFunction(rt, frozenObject));
         auto name = funPtr->getProperty(rt, "name").asString(rt).utf8(rt);
 
         auto clb = [=](
@@ -346,8 +347,8 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
               if (location.isString()) {
                 str += "\nIn file: " + location.asString(rt).utf8(rt);
               }
-              module->errorHandler->setError(str);
-              module->errorHandler->raise();
+              runtimeManager->errorHandler->setError(str);
+              runtimeManager->errorHandler->raise();
             }
 
            rt.global().setProperty(rt, "jsThis", oldJSThis); //clean jsThis
@@ -367,14 +368,14 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
 
           std::vector<std::shared_ptr<ShareableValue>> params;
           for (int i = 0; i < count; ++i) {
-            params.push_back(ShareableValue::adapt(rt, args[i], module));
+            params.push_back(ShareableValue::adapt(rt, args[i], runtimeManager));
           }
 
-          module->scheduler->scheduleOnUI([=] {
-            jsi::Runtime &rt = *module->runtime.get();
+          runtimeManager->scheduler->scheduleOnUI([=] {
+            jsi::Runtime &rt = *runtimeManager->runtime.get();
             auto jsThis = createFrozenWrapper(rt, frozenObject).getObject(rt);
             auto code = jsThis.getProperty(rt, "asString").asString(rt).utf8(rt);
-            std::shared_ptr<jsi::Function> funPtr(module->workletsCache->getFunction(rt, frozenObject));
+            std::shared_ptr<jsi::Function> funPtr(runtimeManager->workletsCache->getFunction(rt, frozenObject));
 
             jsi::Value * args = new jsi::Value[params.size()];
             for (int i = 0; i < params.size(); ++i) {
@@ -392,8 +393,8 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
 
             } catch(std::exception &e) {
               std::string str = e.what();
-              module->errorHandler->setError(str);
-              module->errorHandler->raise();
+              runtimeManager->errorHandler->setError(str);
+              runtimeManager->errorHandler->raise();
             } catch(...) {
               // TODO find out a way to get the error's message on hermes
               jsi::Value location = jsThis.getProperty(rt, "__location");
@@ -401,8 +402,8 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
               if (location.isString()) {
                 str += "\nIn file: " + location.asString(rt).utf8(rt);
               }
-              module->errorHandler->setError(str);
-              module->errorHandler->raise();
+              runtimeManager->errorHandler->setError(str);
+              runtimeManager->errorHandler->raise();
             }
             rt.global().setProperty(rt, "jsThis", oldJSThis); //clean jsThis
 
@@ -418,7 +419,6 @@ jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
       throw "Unable to find conversion method for this type";
     }
   }
-  throw "convert error";
 }
 
 }
diff --git a/node_modules/react-native-reanimated/Common/cpp/Tools/Mapper.cpp b/node_modules/react-native-reanimated/Common/cpp/Tools/Mapper.cpp
index 073fdac..4f68f17 100644
--- a/node_modules/react-native-reanimated/Common/cpp/Tools/Mapper.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/Tools/Mapper.cpp
@@ -1,6 +1,7 @@
 #include "Mapper.h"
 #include "SharedParent.h"
 #include "MutableValue.h"
+#include "RuntimeManager.h"
 
 namespace reanimated {
 
diff --git a/node_modules/react-native-reanimated/Common/cpp/Tools/RuntimeDecorator.cpp b/node_modules/react-native-reanimated/Common/cpp/Tools/RuntimeDecorator.cpp
index 6fe9de9..a647671 100644
--- a/node_modules/react-native-reanimated/Common/cpp/Tools/RuntimeDecorator.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/Tools/RuntimeDecorator.cpp
@@ -5,36 +5,30 @@
 
 namespace reanimated {
 
-void RuntimeDecorator::addNativeObjects(jsi::Runtime &rt,
-                                        UpdaterFunction updater,
-                                        RequestFrameFunction requestFrame,
-                                        ScrollToFunction scrollTo,
-                                        MeasuringFunction measure,
-                                        TimeProviderFunction getCurrentTime) {
+void RuntimeDecorator::decorateRuntime(jsi::Runtime &rt, std::string label) {
+  // This property will be used to find out if a runtime is a custom worklet runtime (e.g. UI, VisionCamera frame processor, ...)
   rt.global().setProperty(rt, "_WORKLET", jsi::Value(true));
-  
-  jsi::Object dummyGlobal(rt);
-  auto dummyFunction = [requestFrame](
-     jsi::Runtime &rt,
-     const jsi::Value &thisValue,
-     const jsi::Value *args,
-     size_t count
-     ) -> jsi::Value {
-   return jsi::Value::undefined();
+  // This property will be used for debugging
+  rt.global().setProperty(rt, "_LABEL", jsi::String::createFromAscii(rt, label));
+
+  auto dummyFunction = [](
+                                      jsi::Runtime &rt,
+                                      const jsi::Value &thisValue,
+                                      const jsi::Value *args,
+                                      size_t count
+                                      ) -> jsi::Value {
+    return jsi::Value::undefined();
   };
-  jsi::Function __reanimatedWorkletInit = jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "__reanimatedWorkletInit"), 1, dummyFunction);
-  
-  dummyGlobal.setProperty(rt, "__reanimatedWorkletInit", __reanimatedWorkletInit);
-  rt.global().setProperty(rt, "global", dummyGlobal);
+  rt.global().setProperty(rt, "__reanimatedWorkletInit", jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "__reanimatedWorkletInit"), 1, dummyFunction));
 
   rt.global().setProperty(rt, "jsThis", jsi::Value::undefined());
 
   auto callback = [](
-      jsi::Runtime &rt,
-      const jsi::Value &thisValue,
-      const jsi::Value *args,
-      size_t count
-      ) -> jsi::Value {
+                     jsi::Runtime &rt,
+                     const jsi::Value &thisValue,
+                     const jsi::Value *args,
+                     size_t count
+                     ) -> jsi::Value {
     const jsi::Value *value = &args[0];
     if (value->isString()) {
       Logger::log(value->getString(rt).utf8(rt).c_str());
@@ -46,10 +40,31 @@ void RuntimeDecorator::addNativeObjects(jsi::Runtime &rt,
       Logger::log("unsupported value type");
     }
     return jsi::Value::undefined();
-    };
+  };
   jsi::Value log = jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "_log"), 1, callback);
-	rt.global().setProperty(rt, "_log", log);
+  rt.global().setProperty(rt, "_log", log);
+
+  auto setGlobalConsole = [](
+                             jsi::Runtime &rt,
+                             const jsi::Value &thisValue,
+                             const jsi::Value *args,
+                             size_t count
+                             ) -> jsi::Value {
+    rt.global().setProperty(rt, "console", args[0]);
+    return jsi::Value::undefined();
+  };
+  rt.global().setProperty(rt, "_setGlobalConsole", jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "_setGlobalConsole"), 1, setGlobalConsole));
+
+  rt.global().setProperty(rt, "global", rt.global());
+}
 
+void RuntimeDecorator::decorateUIRuntime(jsi::Runtime &rt,
+                                         UpdaterFunction updater,
+                                         RequestFrameFunction requestFrame,
+                                         ScrollToFunction scrollTo,
+                                         MeasuringFunction measure,
+                                         TimeProviderFunction getCurrentTime) {
+  RuntimeDecorator::decorateRuntime(rt, "UI");
 
   auto clb = [updater](
       jsi::Runtime &rt,
@@ -115,18 +130,6 @@ void RuntimeDecorator::addNativeObjects(jsi::Runtime &rt,
   jsi::Value measureFunction = jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "_measure"), 1, clb4);
   rt.global().setProperty(rt, "_measure", measureFunction);
 
-  auto clb5 = [](
-      jsi::Runtime &rt,
-      const jsi::Value &thisValue,
-      const jsi::Value *args,
-      size_t count
-      ) -> jsi::Value {
-    rt.global().setProperty(rt, "console", args[0]);
-    return jsi::Value::undefined();
-  };
-  jsi::Value setGlobalConsole = jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "_setGlobalConsole"), 1, clb5);
-  rt.global().setProperty(rt, "_setGlobalConsole", setGlobalConsole);
-  
   auto clb6 = [getCurrentTime](
       jsi::Runtime &rt,
       const jsi::Value &thisValue,
@@ -142,4 +145,13 @@ void RuntimeDecorator::addNativeObjects(jsi::Runtime &rt,
   rt.global().setProperty(rt, "_eventTimestamp", jsi::Value::undefined());
 }
 
+bool RuntimeDecorator::isWorkletRuntime(jsi::Runtime& rt) {
+  auto isUi = rt.global().getProperty(rt, "_WORKLET");
+  return isUi.isBool() && isUi.getBool();
+}
+
+bool RuntimeDecorator::isReactRuntime(jsi::Runtime& rt) {
+  return !isWorkletRuntime(rt);
+}
+
 }
diff --git a/node_modules/react-native-reanimated/Common/cpp/Tools/Scheduler.cpp b/node_modules/react-native-reanimated/Common/cpp/Tools/Scheduler.cpp
index fe73ce3..e750122 100644
--- a/node_modules/react-native-reanimated/Common/cpp/Tools/Scheduler.cpp
+++ b/node_modules/react-native-reanimated/Common/cpp/Tools/Scheduler.cpp
@@ -20,8 +20,8 @@ void Scheduler::setJSCallInvoker(std::shared_ptr<facebook::react::CallInvoker> j
   jsCallInvoker_ = jsCallInvoker;
 }
 
-void Scheduler::setModule(std::shared_ptr<NativeReanimatedModule> module) {
-  this->module = module;
+void Scheduler::setRuntimeManager(std::shared_ptr<RuntimeManager> runtimeManager) {
+  this->runtimeManager = runtimeManager;
 }
 
 Scheduler::~Scheduler() {}
diff --git a/node_modules/react-native-reanimated/Common/cpp/headers/NativeModules/NativeReanimatedModule.h b/node_modules/react-native-reanimated/Common/cpp/headers/NativeModules/NativeReanimatedModule.h
index 258903a..3f7cf99 100644
--- a/node_modules/react-native-reanimated/Common/cpp/headers/NativeModules/NativeReanimatedModule.h
+++ b/node_modules/react-native-reanimated/Common/cpp/headers/NativeModules/NativeReanimatedModule.h
@@ -3,12 +3,12 @@
 #include "NativeReanimatedModuleSpec.h"
 #include "Scheduler.h"
 #include "ErrorHandler.h"
-#include "WorkletsCache.h"
 #include "RuntimeDecorator.h"
 #include "PlatformDepMethodsHolder.h"
 #include <unistd.h>
 #include <memory>
 #include <vector>
+#include "RuntimeManager.h"
 
 namespace reanimated
 {
@@ -20,58 +20,48 @@ class MutableValue;
 class MapperRegistry;
 class EventHandlerRegistry;
 
-class NativeReanimatedModule : public NativeReanimatedModuleSpec
+class NativeReanimatedModule : public NativeReanimatedModuleSpec, public RuntimeManager
 {
   friend ShareableValue;
   friend MutableValue;
 
-  public:
-    NativeReanimatedModule(std::shared_ptr<CallInvoker> jsInvoker,
-                           std::shared_ptr<Scheduler> scheduler,
-                           std::unique_ptr<jsi::Runtime> rt,
-                           std::shared_ptr<ErrorHandler> errorHandler,
-                           std::function<jsi::Value(jsi::Runtime &, const int, const jsi::String &)> propObtainer,
-                           PlatformDepMethodsHolder platformDepMethodsHolder);
+public:
+  NativeReanimatedModule(std::shared_ptr<CallInvoker> jsInvoker,
+                         std::shared_ptr<Scheduler> scheduler,
+                         std::unique_ptr<jsi::Runtime> rt,
+                         std::shared_ptr<ErrorHandler> errorHandler,
+                         std::function<jsi::Value(jsi::Runtime &, const int, const jsi::String &)> propObtainer,
+                         PlatformDepMethodsHolder platformDepMethodsHolder);
 
-    virtual ~NativeReanimatedModule();
+  virtual ~NativeReanimatedModule();
 
-    void installCoreFunctions(jsi::Runtime &rt, const jsi::Value &valueSetter) override;
+  void installCoreFunctions(jsi::Runtime &rt, const jsi::Value &valueSetter) override;
 
-    jsi::Value makeShareable(jsi::Runtime &rt, const jsi::Value &value) override;
-    jsi::Value makeMutable(jsi::Runtime &rt, const jsi::Value &value) override;
-    jsi::Value makeRemote(jsi::Runtime &rt, const jsi::Value &value) override;
+  jsi::Value makeShareable(jsi::Runtime &rt, const jsi::Value &value) override;
+  jsi::Value makeMutable(jsi::Runtime &rt, const jsi::Value &value) override;
+  jsi::Value makeRemote(jsi::Runtime &rt, const jsi::Value &value) override;
 
-    jsi::Value startMapper(jsi::Runtime &rt, const jsi::Value &worklet, const jsi::Value &inputs, const jsi::Value &outputs) override;
-    void stopMapper(jsi::Runtime &rt, const jsi::Value &mapperId) override;
+  jsi::Value startMapper(jsi::Runtime &rt, const jsi::Value &worklet, const jsi::Value &inputs, const jsi::Value &outputs) override;
+  void stopMapper(jsi::Runtime &rt, const jsi::Value &mapperId) override;
 
-    jsi::Value registerEventHandler(jsi::Runtime &rt, const jsi::Value &eventHash, const jsi::Value &worklet) override;
-    void unregisterEventHandler(jsi::Runtime &rt, const jsi::Value &registrationId) override;
+  jsi::Value registerEventHandler(jsi::Runtime &rt, const jsi::Value &eventHash, const jsi::Value &worklet) override;
+  void unregisterEventHandler(jsi::Runtime &rt, const jsi::Value &registrationId) override;
 
-    jsi::Value getViewProp(jsi::Runtime &rt, const jsi::Value &viewTag, const jsi::Value &propName, const jsi::Value &callback) override;
+  jsi::Value getViewProp(jsi::Runtime &rt, const jsi::Value &viewTag, const jsi::Value &propName, const jsi::Value &callback) override;
 
-    void onRender(double timestampMs);
-    void onEvent(std::string eventName, std::string eventAsString);
-    bool isAnyHandlerWaitingForEvent(std::string eventName);
+  void onRender(double timestampMs);
+  void onEvent(std::string eventName, std::string eventAsString);
+  bool isAnyHandlerWaitingForEvent(std::string eventName);
 
-    void maybeRequestRender();
-
-    bool isUIRuntime(jsi::Runtime &rt);
-    bool isHostRuntime(jsi::Runtime &rt);
-  public:
-    std::unique_ptr<jsi::Runtime> runtime;
-  private:
-    std::shared_ptr<MapperRegistry> mapperRegistry;
-    std::shared_ptr<EventHandlerRegistry> eventHandlerRegistry;
-    std::function<void(FrameCallback, jsi::Runtime&)> requestRender;
-    std::shared_ptr<jsi::Value> dummyEvent;
-    std::vector<FrameCallback> frameCallbacks;
-    bool renderRequested = false;
-    std::function<jsi::Value(jsi::Runtime &, const int, const jsi::String &)> propObtainer;
-  public:
-  std::shared_ptr<ErrorHandler> errorHandler;
-  std::shared_ptr<WorkletsCache> workletsCache;
-  std::shared_ptr<ShareableValue> valueSetter;
-  std::shared_ptr<Scheduler> scheduler;
+  void maybeRequestRender();
+private:
+  std::shared_ptr<MapperRegistry> mapperRegistry;
+  std::shared_ptr<EventHandlerRegistry> eventHandlerRegistry;
+  std::function<void(FrameCallback, jsi::Runtime&)> requestRender;
+  std::shared_ptr<jsi::Value> dummyEvent;
+  std::vector<FrameCallback> frameCallbacks;
+  bool renderRequested = false;
+  std::function<jsi::Value(jsi::Runtime &, const int, const jsi::String &)> propObtainer;
 };
 
 } // namespace reanimated
diff --git a/node_modules/react-native-reanimated/Common/cpp/headers/Registries/WorkletsCache.h b/node_modules/react-native-reanimated/Common/cpp/headers/Registries/WorkletsCache.h
index 0ede04c..d700c79 100644
--- a/node_modules/react-native-reanimated/Common/cpp/headers/Registries/WorkletsCache.h
+++ b/node_modules/react-native-reanimated/Common/cpp/headers/Registries/WorkletsCache.h
@@ -13,6 +13,7 @@ using namespace facebook;
 class FrozenObject;
 
 class WorkletsCache {
+private:
   std::unordered_map<long long, std::shared_ptr<jsi::Function>> worklets;
 public:
   std::shared_ptr<jsi::Function> getFunction(jsi::Runtime & rt, std::shared_ptr<reanimated::FrozenObject> frozenObj);
diff --git a/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/FrozenObject.h b/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/FrozenObject.h
index e2a20f4..9811830 100644
--- a/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/FrozenObject.h
+++ b/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/FrozenObject.h
@@ -2,6 +2,7 @@
 
 #include "WorkletsCache.h"
 #include "SharedParent.h"
+#include "RuntimeManager.h"
 #include <jsi/jsi.h>
 
 using namespace facebook;
@@ -19,7 +20,7 @@ class FrozenObject : public jsi::HostObject {
 
   public:
 
-  FrozenObject(jsi::Runtime &rt, const jsi::Object &object, NativeReanimatedModule *module);
+  FrozenObject(jsi::Runtime &rt, const jsi::Object &object, RuntimeManager *runtimeManager);
   jsi::Object shallowClone(jsi::Runtime &rt);
   bool containsHostFunction = false;
 };
diff --git a/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/MutableValue.h b/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/MutableValue.h
index 3299420..9448fce 100644
--- a/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/MutableValue.h
+++ b/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/MutableValue.h
@@ -6,15 +6,16 @@
 #include <jsi/jsi.h>
 #include <map>
 #include "JSIStoreValueUser.h"
+#include "RuntimeManager.h"
 
 using namespace facebook;
 
 namespace reanimated {
 
 class MutableValue : public jsi::HostObject, public std::enable_shared_from_this<MutableValue>, public StoreUser {
-  private:
+private:
   friend MutableValueSetterProxy;
-  NativeReanimatedModule *module;
+  RuntimeManager *runtimeManager;
   std::mutex readWriteMutex;
   std::shared_ptr<ShareableValue> value;
   std::weak_ptr<jsi::Value> animation;
@@ -23,10 +24,10 @@ class MutableValue : public jsi::HostObject, public std::enable_shared_from_this
   void setValue(jsi::Runtime &rt, const jsi::Value &newValue);
   jsi::Value getValue(jsi::Runtime &rt);
 
-  public:
-  MutableValue(jsi::Runtime &rt, const jsi::Value &initial, NativeReanimatedModule *module, std::shared_ptr<Scheduler> s);
+public:
+  MutableValue(jsi::Runtime &rt, const jsi::Value &initial, RuntimeManager *runtimeManager, std::shared_ptr<Scheduler> s);
 
-  public:
+public:
   void set(jsi::Runtime &rt, const jsi::PropNameID &name, const jsi::Value &value);
   jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &name);
   std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime &rt);
diff --git a/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/RemoteObject.h b/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/RemoteObject.h
index 94b064e..4efcb22 100644
--- a/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/RemoteObject.h
+++ b/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/RemoteObject.h
@@ -10,13 +10,12 @@ namespace reanimated {
 
 class RemoteObject: public jsi::HostObject, public StoreUser {
 private:
-  NativeReanimatedModule *module;
   std::weak_ptr<jsi::Value> backing;
   std::unique_ptr<FrozenObject> initializer;
 public:
   void maybeInitializeOnUIRuntime(jsi::Runtime &rt);
-  RemoteObject(jsi::Runtime &rt, jsi::Object &object, NativeReanimatedModule *module, std::shared_ptr<Scheduler> s):
-     StoreUser(s), module(module), initializer(new FrozenObject(rt, object, module)) {}
+  RemoteObject(jsi::Runtime &rt, jsi::Object &object, RuntimeManager *runtimeManager, std::shared_ptr<Scheduler> s):
+     StoreUser(s), initializer(new FrozenObject(rt, object, runtimeManager)) {}
   void set(jsi::Runtime &rt, const jsi::PropNameID &name, const jsi::Value &value);
   jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &name);
   std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime &rt);
diff --git a/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/RuntimeManager.h b/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/RuntimeManager.h
new file mode 100644
index 0000000..31fe7c1
--- /dev/null
+++ b/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/RuntimeManager.h
@@ -0,0 +1,54 @@
+//
+//  RuntimeManager.h
+//  RNReanimated
+//
+//  Created by Marc Rousavy on 05.03.21.
+//  Copyright © 2021 Facebook. All rights reserved.
+//
+
+#pragma once
+
+#include "ShareableValue.h"
+#include "ErrorHandler.h"
+#include "Scheduler.h"
+#include "WorkletsCache.h"
+#include <jsi/jsi.h>
+#include <memory>
+
+namespace reanimated {
+
+using namespace facebook;
+
+/**
+ A class that manages a jsi::Runtime apart from the React-JS runtime.
+ */
+class RuntimeManager {
+public:
+  RuntimeManager(std::unique_ptr<jsi::Runtime>&& runtime,
+                 std::shared_ptr<ErrorHandler> errorHandler,
+                 std::shared_ptr<Scheduler> scheduler): runtime(std::move(runtime)), errorHandler(errorHandler), scheduler(scheduler), workletsCache(std::make_unique<WorkletsCache>()) { }
+public:
+  /**
+   Holds the jsi::Function worklet that is responsible for updating values in JS.
+   Can be null.
+   */
+  std::shared_ptr<ShareableValue> valueSetter;
+  /**
+   Holds the jsi::Runtime this RuntimeManager is managing.
+   */
+  std::unique_ptr<jsi::Runtime> runtime;
+  /**
+   Holds the error handler that will be invoked when any kind of error occurs.
+   */
+  std::shared_ptr<ErrorHandler> errorHandler;
+  /**
+   Holds the Scheduler that is responsible for scheduling work on the UI- or React-JS Thread.
+   */
+  std::shared_ptr<Scheduler> scheduler;
+  /**
+   Holds a list of adapted Worklets which are cached to avoid unneccessary recreation.
+   */
+  std::unique_ptr<WorkletsCache> workletsCache;
+};
+
+}
diff --git a/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/ShareableValue.h b/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/ShareableValue.h
index b1bb2d5..66f10c1 100644
--- a/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/ShareableValue.h
+++ b/node_modules/react-native-reanimated/Common/cpp/headers/SharedItems/ShareableValue.h
@@ -5,6 +5,8 @@
 #include "ValueWrapper.h"
 #include "HostFunctionHandler.h"
 #include "JSIStoreValueUser.h"
+#include "RuntimeManager.h"
+#include "Scheduler.h"
 #include <string>
 #include <mutex>
 #include <unordered_map>
@@ -22,13 +24,13 @@ friend void extractMutables(jsi::Runtime &rt,
                             std::vector<std::shared_ptr<MutableValue>> &res);
 
 private:
-  NativeReanimatedModule *module;
+  RuntimeManager *runtimeManager;
   std::unique_ptr<ValueWrapper> valueContainer;
   std::unique_ptr<jsi::Value> hostValue;
   std::weak_ptr<jsi::Value> remoteValue;
   bool containsHostFunction = false;
 
-  ShareableValue(NativeReanimatedModule *module, std::shared_ptr<Scheduler> s): StoreUser(s), module(module) {}
+  ShareableValue(RuntimeManager *runtimeManager, std::shared_ptr<Scheduler> s): StoreUser(s), runtimeManager(runtimeManager) {}
 
   jsi::Value toJSValue(jsi::Runtime &rt);
   jsi::Object createHost(jsi::Runtime &rt, std::shared_ptr<jsi::HostObject> host);
@@ -40,7 +42,7 @@ public:
   static std::shared_ptr<ShareableValue> adapt(
     jsi::Runtime &rt,
     const jsi::Value &value,
-    NativeReanimatedModule *module,
+    RuntimeManager *runtimeManager,
     ValueType objectType = ValueType::UndefinedType
   );
   jsi::Value getValue(jsi::Runtime &rt);
diff --git a/node_modules/react-native-reanimated/Common/cpp/headers/Tools/RuntimeDecorator.h b/node_modules/react-native-reanimated/Common/cpp/headers/Tools/RuntimeDecorator.h
index 0b53361..ecc518c 100644
--- a/node_modules/react-native-reanimated/Common/cpp/headers/Tools/RuntimeDecorator.h
+++ b/node_modules/react-native-reanimated/Common/cpp/headers/Tools/RuntimeDecorator.h
@@ -12,12 +12,16 @@ using RequestFrameFunction = std::function<void(std::function<void(double)>)>;
 
 class RuntimeDecorator {
 public:
-  static void addNativeObjects(jsi::Runtime &rt,
-                               UpdaterFunction updater,
-                               RequestFrameFunction requestFrame,
-                               ScrollToFunction scrollTo,
-                               MeasuringFunction measure,
-                               TimeProviderFunction getCurrentTime);
+  static void decorateRuntime(jsi::Runtime &rt, std::string label);
+  static void decorateUIRuntime(jsi::Runtime &rt,
+                                UpdaterFunction updater,
+                                RequestFrameFunction requestFrame,
+                                ScrollToFunction scrollTo,
+                                MeasuringFunction measure,
+                                TimeProviderFunction getCurrentTime);
+  
+  static bool isWorkletRuntime(jsi::Runtime &rt);
+  static bool isReactRuntime(jsi::Runtime &rt);
 };
 
 }
diff --git a/node_modules/react-native-reanimated/Common/cpp/headers/Tools/Scheduler.h b/node_modules/react-native-reanimated/Common/cpp/headers/Tools/Scheduler.h
index 9651904..9f2c2eb 100644
--- a/node_modules/react-native-reanimated/Common/cpp/headers/Tools/Scheduler.h
+++ b/node_modules/react-native-reanimated/Common/cpp/headers/Tools/Scheduler.h
@@ -73,20 +73,20 @@ class Queue
   std::condition_variable cond_;
 };
 
-class NativeReanimatedModule;
+class RuntimeManager;
 
 class Scheduler {
   public:
     void scheduleOnJS(std::function<void()> job);
     void setJSCallInvoker(std::shared_ptr<facebook::react::CallInvoker> jsCallInvoker);
-    void setModule(std::shared_ptr<NativeReanimatedModule> module);
+    void setRuntimeManager(std::shared_ptr<RuntimeManager> runtimeManager);
     virtual void scheduleOnUI(std::function<void()> job);
     virtual void triggerUI();
     virtual ~Scheduler();
   protected:
     Queue<std::function<void()>> uiJobs;
     std::shared_ptr<facebook::react::CallInvoker> jsCallInvoker_;
-    std::weak_ptr<NativeReanimatedModule> module;
+    std::weak_ptr<RuntimeManager> runtimeManager;
 };
 
 }
diff --git a/node_modules/react-native-reanimated/ios/native/NativeProxy.mm b/node_modules/react-native-reanimated/ios/native/NativeProxy.mm
index 9618fd0..b1ebf9f 100644
--- a/node_modules/react-native-reanimated/ios/native/NativeProxy.mm
+++ b/node_modules/react-native-reanimated/ios/native/NativeProxy.mm
@@ -111,13 +111,14 @@ static id convertJSIValueToObjCObject(jsi::Runtime &runtime, const jsi::Value &v
       return val;
   };
 
-  std::shared_ptr<Scheduler> scheduler(new REAIOSScheduler(jsInvoker));
 
 #if __has_include(<hermes/hermes.h>)
   std::unique_ptr<jsi::Runtime> animatedRuntime = facebook::hermes::makeHermesRuntime();
 #else
   std::unique_ptr<jsi::Runtime> animatedRuntime = facebook::jsc::makeJSCRuntime();
 #endif
+
+  std::shared_ptr<Scheduler> scheduler = std::make_shared<REAIOSScheduler>(jsInvoker);
   std::shared_ptr<ErrorHandler> errorHandler = std::make_shared<REAIOSErrorHandler>(scheduler);
   std::shared_ptr<NativeReanimatedModule> module;
 
@@ -142,15 +143,15 @@ static id convertJSIValueToObjCObject(jsi::Runtime &runtime, const jsi::Value &v
     getCurrentTime,
   };
 
-module = std::make_shared<NativeReanimatedModule>(jsInvoker,
-                                                  scheduler,
-                                                  std::move(animatedRuntime),
-                                                  errorHandler,
-                                                  propObtainer,
-                                                  platformDepMethodsHolder
-                                                  );
+  module = std::make_shared<NativeReanimatedModule>(jsInvoker,
+                                                    scheduler,
+                                                    std::move(animatedRuntime),
+                                                    errorHandler,
+                                                    propObtainer,
+                                                    platformDepMethodsHolder
+                                                    );
 
-  scheduler->setModule(module);
+  scheduler->setRuntimeManager(module);
 
   [reanimatedModule.nodesManager registerEventHandler:^(NSString *eventName, id<RCTEvent> event) {
     std::string eventNameString([eventName UTF8String]);
diff --git a/node_modules/react-native-reanimated/ios/native/REAIOSScheduler.mm b/node_modules/react-native-reanimated/ios/native/REAIOSScheduler.mm
index 541c4fa..db88b68 100644
--- a/node_modules/react-native-reanimated/ios/native/REAIOSScheduler.mm
+++ b/node_modules/react-native-reanimated/ios/native/REAIOSScheduler.mm
@@ -1,4 +1,5 @@
 #include "REAIOSScheduler.h"
+#include "RuntimeManager.h"
 
 namespace reanimated {
 
@@ -10,25 +11,25 @@
 }
 
 void REAIOSScheduler::scheduleOnUI(std::function<void()> job) {
-  if (module.lock() == nullptr) {
+  if (runtimeManager.lock() == nullptr) {
     return;
   }
 
   if([NSThread isMainThread]) {
-    if (module.lock()) job();
+    if (runtimeManager.lock()) job();
     return;
   }
 
   Scheduler::scheduleOnUI(job);
   if([NSThread isMainThread]) {
-    if (module.lock()) triggerUI();
+    if (runtimeManager.lock()) triggerUI();
     return;
   }
 
-  __block std::weak_ptr<NativeReanimatedModule> blockModule = module;
+  __block std::weak_ptr<RuntimeManager> blockRuntimeManager = runtimeManager;
 
   dispatch_async(dispatch_get_main_queue(), ^{
-    if (blockModule.lock()) triggerUI();
+    if (blockRuntimeManager.lock()) triggerUI();
   });
 }
 
diff --git a/node_modules/react-native-reanimated/ios/native/UIResponder+Reanimated.mm b/node_modules/react-native-reanimated/ios/native/UIResponder+Reanimated.mm
index ab53a53..9a3c5e2 100644
--- a/node_modules/react-native-reanimated/ios/native/UIResponder+Reanimated.mm
+++ b/node_modules/react-native-reanimated/ios/native/UIResponder+Reanimated.mm
@@ -7,12 +7,19 @@
 #import <React/RCTCxxBridgeDelegate.h>
 #import <RNReanimated/REAEventDispatcher.h>
 
-#if RNVERSION >= 64
+#if __has_include(<React/RCTJSIExecutorRuntimeInstaller.h>)
 #import <React/RCTJSIExecutorRuntimeInstaller.h>
+#else
+#define RCTJSIExecutorRuntimeInstaller(x) x
 #endif
 
-#if RNVERSION < 63
+#if __has_include(<ReactCommon/CallInvoker.h>)
+#import <ReactCommon/CallInvoker.h>
+#define NEW_CALL_INVOKER
+#elif __has_include(<ReactCommon/BridgeJSCallInvoker.h>)
 #import <ReactCommon/BridgeJSCallInvoker.h>
+#else
+#error JS-CallInvoker import could not be found!
 #endif
 
 #if __has_include(<React/HermesExecutorFactory.h>)
@@ -47,24 +54,20 @@ @implementation UIResponder (Reanimated)
     }
     __typeof(self) strongSelf = weakSelf;
     if (strongSelf) {
-#if RNVERSION >= 63
-      auto reanimatedModule = reanimated::createReanimatedModule(bridge.jsCallInvoker);
+#ifdef NEW_CALL_INVOKER
+      auto callInvoker = bridge.jsCallInvoker;
 #else
       auto callInvoker = std::make_shared<react::BridgeJSCallInvoker>(bridge.reactInstance);
-      auto reanimatedModule = reanimated::createReanimatedModule(callInvoker);
 #endif
+      auto reanimatedModule = reanimated::createReanimatedModule(callInvoker);
       runtime.global().setProperty(runtime,
                                    jsi::PropNameID::forAscii(runtime, "__reanimatedModuleProxy"),
                                    jsi::Object::createFromHostObject(runtime, reanimatedModule));
     }
   };
 
-#if RNVERSION >= 64
   // installs globals such as console, nativePerformanceNow, etc.
   return std::make_unique<ExecutorFactory>(RCTJSIExecutorRuntimeInstaller(executor));
-#else
-  return std::make_unique<ExecutorFactory>(executor);
-#endif
 }
 
 @end
